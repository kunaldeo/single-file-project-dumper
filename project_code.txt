Project Path: /Users/kunal/projects/single-file-project-dumper

Source Tree:
```
â”œâ”€â”€ project_dumper
    â””â”€â”€ __init__.py
    â””â”€â”€ config.py
    â””â”€â”€ features.py
    â””â”€â”€ file_utils.py
    â””â”€â”€ interactive.py
    â””â”€â”€ preferences.py
    â””â”€â”€ project_utils.py
    â””â”€â”€ template.py
    â””â”€â”€ token_utils.py
    â””â”€â”€ ui_utils.py
```

`project_dumper/config.py`:
```py
import os
import json
from typing import Dict
from .project_utils import detect_project_type, get_smart_defaults


def load_config(root_dir: str) -> Dict:
    """Load .claude-dump config file if it exists."""
    config_file = os.path.join(root_dir, '.claude-dump')
    if os.path.exists(config_file):
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
                return config
        except Exception as e:
            print(f"Warning: Error loading .claude-dump config: {e}")
    return {}


def save_config_template(root_dir: str) -> None:
    """Save a template .claude-dump config file."""
    project_type = detect_project_type(root_dir)
    smart_defaults = get_smart_defaults(project_type) if project_type else {}
    
    template = {
        "output_file": "project_code.txt",
        "state_file": ".file_dumper_state.json",
        "include": smart_defaults.get('include', ["*"]),
        "exclude": smart_defaults.get('exclude', []),
        "max_file_size_kb": smart_defaults.get('max_file_size', 1000),
        "auto_copy": True,
        "project_type": project_type,
        "template": None,
        "token_limit_warnings": {
            "claude": 150000,
            "gpt-4": 100000,
            "gemini": 800000
        }
    }
    
    config_file = os.path.join(root_dir, '.claude-dump')
    with open(config_file, 'w') as f:
        json.dump(template, f, indent=2)
    
    print(f"\nCreated .claude-dump config file with smart defaults for {project_type or 'generic'} project.")
    print("Edit this file to customize your dump settings.")


def load_state(state_file: str) -> Dict:
    """Load previous file selection state from JSON file."""
    if os.path.exists(state_file):
        with open(state_file, 'r') as f:
            state = json.load(f)
            state['skipped_dirs'] = set(state.get('skipped_dirs', []))
            state['selected_dirs'] = set(state.get('selected_dirs', []))
            return state
    return {'selected_files': {}, 'skipped_dirs': set(), 'selected_dirs': set()}


def save_state(state_file: str, state: Dict) -> None:
    """Save current selection state to JSON file."""
    json_state = {
        'root_dir': state['root_dir'],
        'selected_files': state['selected_files'],
        'skipped_dirs': list(state['skipped_dirs']),
        'selected_dirs': list(state['selected_dirs'])
    }
    with open(state_file, 'w') as f:
        json.dump(json_state, f, indent=2)
```

`project_dumper/project_utils.py`:
```py
import os
from pathlib import Path
from typing import Optional, Dict, List


def detect_project_type(root_dir: str) -> Optional[str]:
    """Detect project type based on files present."""
    indicators = {
        'python': ['requirements.txt', 'setup.py', 'pyproject.toml', 'Pipfile'],
        'javascript': ['package.json', 'yarn.lock', 'package-lock.json'],
        'typescript': ['tsconfig.json', 'package.json'],
        'rust': ['Cargo.toml', 'Cargo.lock'],
        'go': ['go.mod', 'go.sum'],
        'java': ['pom.xml', 'build.gradle', 'build.gradle.kts'],
        'cpp': ['CMakeLists.txt', 'Makefile', '*.cpp', '*.h'],
        'ruby': ['Gemfile', 'Gemfile.lock', '*.rb'],
        'php': ['composer.json', 'composer.lock'],
        'swift': ['Package.swift', '*.xcodeproj'],
        'kotlin': ['build.gradle.kts', '*.kt'],
        'scala': ['build.sbt', '*.scala'],
    }
    
    for project_type, files in indicators.items():
        for file_pattern in files:
            if '*' in file_pattern:
                # Handle wildcards
                if list(Path(root_dir).glob(file_pattern)):
                    return project_type
            else:
                if os.path.exists(os.path.join(root_dir, file_pattern)):
                    return project_type
    return None


def get_smart_defaults(project_type: str) -> Dict:
    """Get smart defaults based on project type."""
    defaults = {
        'python': {
            'include': ['*.py', '*.pyx', '*.pxd', '*.pyi'],
            'exclude': ['__pycache__/*', '*.pyc', 'venv/*', '.venv/*', 'build/*', 'dist/*', '*.egg-info/*'],
            'max_file_size': 1000
        },
        'javascript': {
            'include': ['*.js', '*.jsx', '*.mjs', '*.json', '*.md'],
            'exclude': ['node_modules/*', 'dist/*', 'build/*', 'coverage/*', '.next/*'],
            'max_file_size': 500
        },
        'typescript': {
            'include': ['*.ts', '*.tsx', '*.js', '*.jsx', '*.json', '*.md'],
            'exclude': ['node_modules/*', 'dist/*', 'build/*', 'coverage/*', '.next/*', '*.d.ts'],
            'max_file_size': 500
        },
        'rust': {
            'include': ['*.rs', 'Cargo.toml', '*.md'],
            'exclude': ['target/*', 'Cargo.lock'],
            'max_file_size': 1000
        },
        'go': {
            'include': ['*.go', 'go.mod', 'go.sum', '*.md'],
            'exclude': ['vendor/*', 'bin/*'],
            'max_file_size': 1000
        },
        'java': {
            'include': ['*.java', '*.xml', 'pom.xml', '*.gradle', '*.properties', '*.md'],
            'exclude': ['target/*', 'build/*', '.gradle/*', '*.class'],
            'max_file_size': 1000
        },
        'cpp': {
            'include': ['*.cpp', '*.h', '*.hpp', '*.c', '*.cc', 'CMakeLists.txt', 'Makefile', '*.md'],
            'exclude': ['build/*', 'cmake-build-*/*', '*.o', '*.obj', '*.exe'],
            'max_file_size': 1000
        },
        'ruby': {
            'include': ['*.rb', '*.rake', 'Gemfile', 'Rakefile', '*.gemspec', '*.md'],
            'exclude': ['vendor/*', '.bundle/*', 'tmp/*', 'log/*'],
            'max_file_size': 500
        },
        'php': {
            'include': ['*.php', 'composer.json', '*.md'],
            'exclude': ['vendor/*', 'cache/*', 'logs/*'],
            'max_file_size': 500
        }
    }
    return defaults.get(project_type, {})
```

`project_dumper/preferences.py`:
```py
"""User preferences management for the project dumper."""

import os
import json
from typing import Dict, Any, Optional
from pathlib import Path


def get_preferences_file() -> str:
    """Get the path to the user preferences file."""
    config_dir = Path.home() / '.config' / 'project-dumper'
    config_dir.mkdir(parents=True, exist_ok=True)
    return str(config_dir / 'preferences.json')


def load_preferences() -> Dict[str, Any]:
    """Load user preferences."""
    prefs_file = get_preferences_file()
    
    if os.path.exists(prefs_file):
        try:
            with open(prefs_file, 'r') as f:
                return json.load(f)
        except:
            pass
    
    # Default preferences
    return {
        'default_output_file': 'project_code.txt',
        'auto_copy': False,
        'create_manifest': False,
        'color_output': True,
        'recent_projects': [],
        'favorite_templates': [],
        'quick_patterns': {
            'python': ['*.py', '!__pycache__', '!*.pyc'],
            'javascript': ['*.js', '*.jsx', '!node_modules'],
            'typescript': ['*.ts', '*.tsx', '!node_modules', '!*.d.ts']
        }
    }


def save_preferences(prefs: Dict[str, Any]) -> None:
    """Save user preferences."""
    prefs_file = get_preferences_file()
    
    with open(prefs_file, 'w') as f:
        json.dump(prefs, f, indent=2)


def add_recent_project(project_path: str) -> None:
    """Add a project to recent projects list."""
    prefs = load_preferences()
    
    # Remove if already exists
    if project_path in prefs['recent_projects']:
        prefs['recent_projects'].remove(project_path)
    
    # Add to front
    prefs['recent_projects'].insert(0, project_path)
    
    # Keep only last 10
    prefs['recent_projects'] = prefs['recent_projects'][:10]
    
    save_preferences(prefs)


def get_quick_pattern(pattern_name: str) -> Optional[list]:
    """Get a quick pattern by name."""
    prefs = load_preferences()
    return prefs['quick_patterns'].get(pattern_name)


def save_quick_pattern(name: str, patterns: list) -> None:
    """Save a quick pattern."""
    prefs = load_preferences()
    prefs['quick_patterns'][name] = patterns
    save_preferences(prefs)
```

`project_dumper/__init__.py`:
```py
"""
Project Dumper - A tool to create single-file dumps of projects with gitignore support.
"""

__version__ = "0.2.0"
```

`project_dumper/features.py`:
```py
"""Additional creative features for the project dumper."""

import os
import json
import hashlib
from datetime import datetime
from typing import Dict, List, Optional, Set
from .file_utils import format_file_size
from .token_utils import estimate_tokens
from .ui_utils import print_status, colored, Colors, print_header


def create_dump_manifest(root_dir: str, selected_files: Dict[str, bool], 
                        output_file: str, config: Dict) -> str:
    """Create a manifest file with metadata about the dump."""
    manifest = {
        "timestamp": datetime.now().isoformat(),
        "project_path": os.path.abspath(root_dir),
        "project_type": config.get("project_type", "unknown"),
        "output_file": output_file,
        "statistics": {
            "total_files": len(selected_files),
            "selected_files": sum(1 for v in selected_files.values() if v),
            "total_size": 0,
            "token_estimates": {}
        },
        "files": []
    }
    
    # Calculate statistics
    for file_path, selected in selected_files.items():
        if selected:
            full_path = os.path.join(root_dir, file_path)
            try:
                size = os.path.getsize(full_path)
                manifest["statistics"]["total_size"] += size
                
                with open(full_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    
                # Calculate file hash
                file_hash = hashlib.md5(content.encode()).hexdigest()[:8]
                
                manifest["files"].append({
                    "path": file_path,
                    "size": size,
                    "hash": file_hash,
                    "tokens": {
                        "claude": estimate_tokens(content, "claude"),
                        "gpt-4": estimate_tokens(content, "gpt-4")
                    }
                })
            except:
                pass
    
    # Total token estimates
    total_content = ""
    for file_data in manifest["files"]:
        full_path = os.path.join(root_dir, file_data["path"])
        try:
            with open(full_path, 'r', encoding='utf-8') as f:
                total_content += f.read() + "\n"
        except:
            pass
    
    manifest["statistics"]["token_estimates"] = {
        "claude": estimate_tokens(total_content, "claude"),
        "gpt-4": estimate_tokens(total_content, "gpt-4"),
        "gemini": estimate_tokens(total_content, "gemini")
    }
    
    # Save manifest
    manifest_file = output_file.replace('.txt', '.manifest.json')
    with open(manifest_file, 'w') as f:
        json.dump(manifest, f, indent=2)
    
    return manifest_file


def generate_dump_summary(root_dir: str, selected_files: Dict[str, bool]) -> str:
    """Generate a human-readable summary of the dump."""
    summary_lines = []
    
    # File type breakdown
    extensions = {}
    total_size = 0
    
    for file_path, selected in selected_files.items():
        if selected:
            ext = os.path.splitext(file_path)[1] or 'no extension'
            extensions[ext] = extensions.get(ext, 0) + 1
            
            try:
                size = os.path.getsize(os.path.join(root_dir, file_path))
                total_size += size
            except:
                pass
    
    summary_lines.append("ðŸ“Š DUMP SUMMARY")
    summary_lines.append("=" * 40)
    summary_lines.append(f"Total files: {sum(1 for v in selected_files.values() if v)}")
    summary_lines.append(f"Total size: {format_file_size(total_size)}")
    summary_lines.append("\nFile types:")
    
    # Sort by count
    sorted_exts = sorted(extensions.items(), key=lambda x: x[1], reverse=True)
    for ext, count in sorted_exts[:10]:
        summary_lines.append(f"  {ext:>15}: {count:>4} files")
    
    if len(sorted_exts) > 10:
        summary_lines.append(f"  ... and {len(sorted_exts) - 10} more types")
    
    return "\n".join(summary_lines)


def create_incremental_dump(root_dir: str, selected_files: Dict[str, bool], 
                           previous_manifest: Optional[str] = None) -> Set[str]:
    """Create an incremental dump by comparing with previous manifest."""
    if not previous_manifest or not os.path.exists(previous_manifest):
        # No previous manifest, include all selected files
        return set(f for f, s in selected_files.items() if s)
    
    # Load previous manifest
    with open(previous_manifest, 'r') as f:
        prev = json.load(f)
    
    # Build hash map of previous files
    prev_hashes = {f["path"]: f["hash"] for f in prev.get("files", [])}
    
    # Find changed files
    changed_files = set()
    
    for file_path, selected in selected_files.items():
        if not selected:
            continue
            
        full_path = os.path.join(root_dir, file_path)
        
        # New file
        if file_path not in prev_hashes:
            changed_files.add(file_path)
            continue
        
        # Check if file has changed
        try:
            with open(full_path, 'r', encoding='utf-8') as f:
                content = f.read()
                current_hash = hashlib.md5(content.encode()).hexdigest()[:8]
                
            if current_hash != prev_hashes[file_path]:
                changed_files.add(file_path)
        except:
            # Error reading file, include it anyway
            changed_files.add(file_path)
    
    return changed_files


def suggest_related_files(root_dir: str, selected_files: Dict[str, bool]) -> List[str]:
    """Suggest related files that might be worth including."""
    suggestions = []
    selected_set = set(f for f, s in selected_files.items() if s)
    
    # Common patterns to look for
    patterns = {
        "test": ["test_", "_test", ".test.", "tests/"],
        "config": ["config", "settings", ".env", ".ini", ".yaml", ".yml"],
        "docs": ["README", "CHANGELOG", "LICENSE", "docs/", ".md"],
        "interface": [".proto", ".graphql", ".swagger", "api/"],
        "ci": [".github/", ".gitlab", "Jenkinsfile", ".travis"],
    }
    
    for category, keywords in patterns.items():
        category_files = []
        
        for file_path in selected_files:
            if file_path in selected_set:
                continue
                
            file_lower = file_path.lower()
            if any(kw in file_lower for kw in keywords):
                category_files.append(file_path)
        
        if category_files:
            suggestions.extend(category_files[:3])  # Max 3 per category
    
    return suggestions[:10]  # Return max 10 suggestions


def export_to_formats(output_file: str, format_type: str = "markdown") -> Optional[str]:
    """Export the dump to different formats."""
    if not os.path.exists(output_file):
        return None
    
    with open(output_file, 'r', encoding='utf-8') as f:
        content = f.read()
    
    if format_type == "json":
        # Convert to JSON format
        lines = content.split('\n')
        json_data = {
            "content": content,
            "lines": len(lines),
            "size": len(content)
        }
        
        json_file = output_file.replace('.txt', '.json')
        with open(json_file, 'w') as f:
            json.dump(json_data, f, indent=2)
        
        return json_file
    
    elif format_type == "html":
        # Basic HTML conversion
        html_content = f"""<!DOCTYPE html>
<html>
<head>
    <title>Project Dump</title>
    <style>
        body {{ font-family: monospace; white-space: pre-wrap; }}
        .file-header {{ background: #f0f0f0; padding: 5px; margin: 10px 0; }}
        pre {{ background: #f8f8f8; padding: 10px; overflow-x: auto; }}
    </style>
</head>
<body>
<pre>{content}</pre>
</body>
</html>"""
        
        html_file = output_file.replace('.txt', '.html')
        with open(html_file, 'w') as f:
            f.write(html_content)
        
        return html_file
    
    return None
```

`project_dumper/ui_utils.py`:
```py
"""UI utilities for colored output and better user experience."""

import os
import sys
from typing import Optional

# ANSI color codes
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    DIM = '\033[2m'

# Check if colors should be disabled
NO_COLOR = os.environ.get('NO_COLOR') or not sys.stdout.isatty()

def colored(text: str, color: str, bold: bool = False) -> str:
    """Apply color to text if colors are enabled."""
    if NO_COLOR:
        return text
    
    prefix = color
    if bold:
        prefix = Colors.BOLD + prefix
    
    return f"{prefix}{text}{Colors.ENDC}"

def print_header(text: str) -> None:
    """Print a formatted header."""
    width = 50
    print("\n" + colored("=" * width, Colors.CYAN, bold=True))
    print(colored(text.center(width), Colors.CYAN, bold=True))
    print(colored("=" * width, Colors.CYAN, bold=True))

def print_status(message: str, status: str = "info") -> None:
    """Print a status message with appropriate color."""
    icons = {
        "info": ("â„¹", Colors.BLUE),
        "success": ("âœ“", Colors.GREEN),
        "warning": ("âš ", Colors.YELLOW),
        "error": ("âœ—", Colors.RED),
        "question": ("?", Colors.CYAN)
    }
    
    icon, color = icons.get(status, ("â€¢", Colors.DIM))
    print(f"{colored(icon, color, bold=True)} {message}")

def print_progress(current: int, total: int, label: str = "") -> None:
    """Print a progress indicator."""
    if total == 0:
        return
    
    percentage = (current / total) * 100
    bar_length = 30
    filled = int(bar_length * current / total)
    
    bar = "â–ˆ" * filled + "â–‘" * (bar_length - filled)
    
    if label:
        label = f" {label}"
    
    print(f"\r{colored(bar, Colors.GREEN)} {percentage:3.0f}%{label}", end="", flush=True)
    
    if current == total:
        print()  # New line when complete

def format_size_colored(size: int) -> str:
    """Format file size with color based on size."""
    from .file_utils import format_file_size
    
    size_str = format_file_size(size)
    
    # Color based on size
    if size < 10 * 1024:  # < 10KB
        return colored(size_str, Colors.GREEN)
    elif size < 100 * 1024:  # < 100KB
        return colored(size_str, Colors.YELLOW)
    elif size < 1024 * 1024:  # < 1MB
        return colored(size_str, Colors.YELLOW, bold=True)
    else:  # >= 1MB
        return colored(size_str, Colors.RED, bold=True)

def prompt_yes_no(question: str, default: Optional[bool] = None) -> bool:
    """Prompt user for yes/no answer with color."""
    if default is True:
        prompt = f"{colored('?', Colors.CYAN, bold=True)} {question} [Y/n]: "
    elif default is False:
        prompt = f"{colored('?', Colors.CYAN, bold=True)} {question} [y/N]: "
    else:
        prompt = f"{colored('?', Colors.CYAN, bold=True)} {question} [y/n]: "
    
    while True:
        answer = input(prompt).strip().lower()
        
        if not answer and default is not None:
            return default
        
        if answer in ['y', 'yes']:
            return True
        elif answer in ['n', 'no']:
            return False
        else:
            print_status("Please answer 'y' or 'n'", "warning")

def clear_line() -> None:
    """Clear the current line."""
    print('\r' + ' ' * 80 + '\r', end='', flush=True)
```

`project_dumper/interactive.py`:
```py
import os
import fnmatch
import re
import subprocess
import platform
from typing import Dict, Set, Tuple, List
from .file_utils import format_file_size
from .token_utils import estimate_tokens, show_token_analysis
from .ui_utils import (
    colored, print_header, print_status, format_size_colored,
    prompt_yes_no, Colors
)
from .features import suggest_related_files, generate_dump_summary


def interactive_edit_mode(root_dir: str, selected_files: Dict[str, bool], 
                         skipped_dirs: Set[str], selected_dirs: Set[str],
                         gitignore_patterns: List[str], output_file: str) -> Tuple[Dict[str, bool], bool]:
    """Interactive mode to edit file selections after initial scan."""
    while True:
        print_header("INTERACTIVE EDIT MODE")
        
        # Count selected files
        selected_count = sum(1 for v in selected_files.values() if v)
        total_count = len(selected_files)
        
        # Color the count based on selection status
        if selected_count == 0:
            count_color = Colors.RED
        elif selected_count == total_count:
            count_color = Colors.YELLOW
        else:
            count_color = Colors.GREEN
            
        print(f"\nCurrently selected: {colored(str(selected_count), count_color, bold=True)} / {total_count} files")
        
        print(f"\n{colored('Options:', Colors.CYAN, bold=True)}")
        print(f"  {colored('1', Colors.YELLOW)}. View/edit selected files")
        print(f"  {colored('2', Colors.YELLOW)}. View/edit excluded files")
        print(f"  {colored('3', Colors.YELLOW)}. Select all files matching pattern")
        print(f"  {colored('4', Colors.YELLOW)}. Deselect all files matching pattern")
        print(f"  {colored('5', Colors.YELLOW)}. Preview output")
        print(f"  {colored('6', Colors.GREEN, bold=True)}. Save and dump")
        print(f"  {colored('7', Colors.RED)}. Exit without saving")
        print(f"  {colored('8', Colors.YELLOW)}. Show file size summary")
        print(f"  {colored('9', Colors.YELLOW)}. Show token analysis")
        print(f"  {colored('10', Colors.CYAN)}. Show suggested files")
        print(f"  {colored('11', Colors.CYAN)}. Quick summary")
        
        choice = input(f"\n{colored('â†’', Colors.GREEN, bold=True)} Enter your choice (1-11): ").strip()
        
        if choice == '1':
            # View/edit selected files
            selected_list = sorted([f for f, v in selected_files.items() if v])
            if not selected_list:
                print("\nNo files currently selected.")
                continue
                
            print("\nSelected files:")
            for i, file in enumerate(selected_list, 1):
                print(f"  {i}. {file}")
            
            file_num = input(f"\n{colored('?', Colors.CYAN, bold=True)} Enter file number to deselect (or 'q' to go back): ").strip()
            if file_num != 'q' and file_num.isdigit():
                idx = int(file_num) - 1
                if 0 <= idx < len(selected_list):
                    selected_files[selected_list[idx]] = False
                    print_status(f"Deselected: {selected_list[idx]}", "success")
                    
        elif choice == '2':
            # View/edit excluded files
            excluded_list = sorted([f for f, v in selected_files.items() if not v])
            if not excluded_list:
                print("\nNo files currently excluded.")
                continue
                
            print("\nExcluded files:")
            for i, file in enumerate(excluded_list, 1):
                print(f"  {i}. {file}")
            
            file_num = input(f"\n{colored('?', Colors.CYAN, bold=True)} Enter file number to select (or 'q' to go back): ").strip()
            if file_num != 'q' and file_num.isdigit():
                idx = int(file_num) - 1
                if 0 <= idx < len(excluded_list):
                    selected_files[excluded_list[idx]] = True
                    print_status(f"Selected: {excluded_list[idx]}", "success")
                    
        elif choice == '3':
            # Select by pattern
            pattern = input("\nEnter pattern to select (e.g., *.py, test_*, **/models/*): ").strip()
            if pattern:
                count = 0
                for file in selected_files:
                    if fnmatch.fnmatch(file, pattern) or re.search(pattern, file):
                        if not selected_files[file]:
                            selected_files[file] = True
                            count += 1
                print_status(f"Selected {count} files matching '{pattern}'", "success")
                
        elif choice == '4':
            # Deselect by pattern
            pattern = input("\nEnter pattern to deselect (e.g., *.pyc, __pycache__/*): ").strip()
            if pattern:
                count = 0
                for file in selected_files:
                    if fnmatch.fnmatch(file, pattern) or re.search(pattern, file):
                        if selected_files[file]:
                            selected_files[file] = False
                            count += 1
                print_status(f"Deselected {count} files matching '{pattern}'", "success")
                
        elif choice == '5':
            # Preview output
            preview_output(root_dir, selected_files, output_file)
            
        elif choice == '6':
            # Save and dump
            return selected_files, True
            
        elif choice == '7':
            # Exit without saving
            if prompt_yes_no("Are you sure you want to exit without saving?", default=False):
                return selected_files, False
                
        elif choice == '8':
            # Show file size summary
            show_file_size_summary(root_dir, selected_files)
        
        elif choice == '9':
            # Token analysis
            show_token_analysis(root_dir, selected_files)
            
        elif choice == '10':
            # Show suggested files
            show_file_suggestions(root_dir, selected_files)
            
        elif choice == '11':
            # Quick summary
            summary = generate_dump_summary(root_dir, selected_files)
            print(f"\n{colored(summary, Colors.CYAN)}")
            
        else:
            print_status("Invalid choice. Please try again.", "warning")


def preview_output(root_dir: str, selected_files: Dict[str, bool], output_file: str) -> None:
    """Preview the output that would be generated."""
    selected_list = sorted([f for f, v in selected_files.items() if v])
    
    print_header("OUTPUT PREVIEW")
    print(f"\n{colored('Output file:', Colors.CYAN)} {output_file}")
    print(f"{colored('Selected files:', Colors.CYAN)} {len(selected_list)}")
    
    # Calculate total size
    total_size = 0
    for file in selected_list:
        try:
            total_size += os.path.getsize(os.path.join(root_dir, file))
        except:
            pass
    
    print(f"{colored('Total size:', Colors.CYAN)} {format_size_colored(total_size)}")
    
    # Estimate tokens for different models
    print(f"\n{colored('Estimated token counts:', Colors.CYAN, bold=True)}")
    total_text = ""
    for file in selected_list:
        try:
            with open(os.path.join(root_dir, file), 'r', encoding='utf-8') as f:
                total_text += f.read() + "\n"
        except:
            pass
    
    for model in ['claude', 'gpt-4', 'gemini']:
        tokens = estimate_tokens(total_text, model)
        print(f"  {model.capitalize():>8}: ~{tokens:,} tokens")
    
    print("\nFirst 10 files:")
    for file in selected_list[:10]:
        print(f"  - {file}")
    
    if len(selected_list) > 10:
        print(f"  ... and {len(selected_list) - 10} more files")


def show_file_size_summary(root_dir: str, selected_files: Dict[str, bool]) -> None:
    """Show summary of file sizes."""
    sizes = []
    for file, selected in selected_files.items():
        try:
            size = os.path.getsize(os.path.join(root_dir, file))
            sizes.append((file, size, selected))
        except:
            pass
    
    # Sort by size descending
    sizes.sort(key=lambda x: x[1], reverse=True)
    
    print_header("FILE SIZE SUMMARY")
    
    print(f"\n{colored('Top 10 largest files:', Colors.CYAN, bold=True)}")
    for file, size, selected in sizes[:10]:
        if selected:
            status = colored("[SELECTED]", Colors.GREEN)
        else:
            status = colored("[EXCLUDED]", Colors.RED)
        print(f"  {format_size_colored(size):>10} {status:>11} {file}")
    
    # Summary stats
    selected_size = sum(size for _, size, selected in sizes if selected)
    total_size = sum(size for _, size, _ in sizes)
    
    print(f"\n{colored('Total size of selected files:', Colors.CYAN)} {format_size_colored(selected_size)}")
    print(f"{colored('Total size of all files:', Colors.CYAN)} {format_size_colored(total_size)}")


def show_file_suggestions(root_dir: str, selected_files: Dict[str, bool]) -> None:
    """Show suggested files that might be worth including."""
    print_header("FILE SUGGESTIONS")
    
    suggestions = suggest_related_files(root_dir, selected_files)
    
    if not suggestions:
        print_status("No additional files to suggest.", "info")
        return
    
    print(f"\n{colored('Found related files you might want to include:', Colors.CYAN, bold=True)}\n")
    
    for i, file in enumerate(suggestions, 1):
        try:
            size = os.path.getsize(os.path.join(root_dir, file))
            size_str = format_size_colored(size)
            print(f"  {colored(str(i), Colors.YELLOW)}. {file} ({size_str})")
        except:
            print(f"  {colored(str(i), Colors.YELLOW)}. {file}")
    
    add_all = prompt_yes_no("\nAdd all suggested files?", default=False)
    if add_all:
        count = 0
        for file in suggestions:
            if file in selected_files and not selected_files[file]:
                selected_files[file] = True
                count += 1
        print_status(f"Added {count} suggested files.", "success")
    else:
        # Ask for individual files
        while True:
            choice = input(f"\n{colored('?', Colors.CYAN, bold=True)} Enter file number to add (or 'q' to finish): ").strip()
            if choice == 'q':
                break
            if choice.isdigit():
                idx = int(choice) - 1
                if 0 <= idx < len(suggestions):
                    file = suggestions[idx]
                    if file in selected_files:
                        selected_files[file] = True
                        print_status(f"Added: {file}", "success")


def copy_to_clipboard(text: str) -> bool:
    """Copy text to clipboard. Returns True if successful."""
    try:
        if platform.system() == 'Darwin':  # macOS
            subprocess.run(['pbcopy'], input=text.encode('utf-8'), check=True)
        elif platform.system() == 'Linux':
            # Try xclip first, then xsel
            try:
                subprocess.run(['xclip', '-selection', 'clipboard'], 
                             input=text.encode('utf-8'), check=True)
            except:
                subprocess.run(['xsel', '--clipboard', '--input'], 
                             input=text.encode('utf-8'), check=True)
        elif platform.system() == 'Windows':
            subprocess.run(['clip'], input=text.encode('utf-8'), check=True, shell=True)
        return True
    except:
        return False
```

`project_dumper/template.py`:
```py
"""Template handling for the project dumper."""

# Try to import pybars, but make it optional
try:
    from pybars import Compiler
    HAS_PYBARS = True
except ImportError:
    HAS_PYBARS = False
    Compiler = None


def load_template(template_path: str) -> str:
    """Load a Handlebars template file."""
    if not template_path:
        # Default template with proper variable names
        return """Project Path: {{absolute_code_path}}

Source Tree:
```
{{source_tree}}
```

{{#each files}}
{{#if code}}
`{{path}}`:
{{{code}}}

{{/if}}
{{/each}}"""
    
    try:
        with open(template_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        print(f"Error loading template {template_path}: {e}")
        print("Using default template instead")
        return load_template(None)  # Fall back to default template


def render_template(template: str, context: dict) -> str:
    """Render a template with the given context."""
    if not HAS_PYBARS:
        # Fallback: simple string replacement for basic templates
        result = template
        for key, value in context.items():
            result = result.replace(f"{{{{{key}}}}}", str(value))
        return result
    
    compiler = Compiler()
    compiled = compiler.compile(template)
    return compiled(context)
```

`project_dumper/file_utils.py`:
```py
import os
import fnmatch
from typing import List, Dict, Set, Tuple
from pathlib import Path


def find_git_dir(start_path: str) -> str:
    """
    Search up the directory tree for a .git directory.
    Returns the path containing .git, or None if not found.
    """
    current = os.path.abspath(start_path)
    while current != os.path.dirname(current):  # Stop at root directory
        if os.path.exists(os.path.join(current, '.git')):
            return current
        current = os.path.dirname(current)
    return None


def load_gitignore(start_dir: str) -> List[str]:
    """
    Load gitignore patterns, searching up the directory tree for .gitignore files.
    Also includes common patterns and other ignore files.
    
    Args:
        start_dir: Directory to start searching from
        
    Returns:
        List of gitignore patterns
    """
    # Use the new comprehensive ignore file loader
    return load_ignore_files(start_dir)


def get_default_ignore_patterns() -> List[str]:
    """Get default patterns for directories that should always be ignored."""
    return [
        '.git', '.svn', '.hg', '.bzr',  # Version control
        '.vscode', '.idea', '.sublime-*', '*.swp', '*.swo', '*~',  # IDE/Editor
        'node_modules', 'bower_components',  # JavaScript
        '__pycache__', '*.pyc', '*.pyo', '*.pyd', '.Python',  # Python
        'target', '.gradle', '.m2',  # Java/Maven/Gradle
        '.stack-work', '.cabal-sandbox',  # Haskell
        '.coverage', 'htmlcov', '.pytest_cache', '.tox',  # Testing
        '.DS_Store', 'Thumbs.db', 'desktop.ini',  # OS files
    ]


def load_ignore_files(start_dir: str) -> List[str]:
    """
    Load patterns from various ignore files (.gitignore, .dockerignore, etc.).
    
    Args:
        start_dir: Directory to start searching from
        
    Returns:
        List of ignore patterns
    """
    patterns = get_default_ignore_patterns()
    
    # Find git root directory
    git_root = find_git_dir(start_dir)
    search_dirs = [start_dir]
    if git_root and git_root != start_dir:
        search_dirs.append(git_root)
    
    # Check various ignore files
    ignore_files = ['.gitignore', '.dockerignore', '.npmignore']
    
    for dir_path in search_dirs:
        for ignore_file in ignore_files:
            ignore_path = os.path.join(dir_path, ignore_file)
            if os.path.exists(ignore_path):
                with open(ignore_path, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            patterns.append(line)
    
    return patterns


def is_ignored(path: str, gitignore_patterns: List[str]) -> bool:
    """Check if a path matches any gitignore patterns."""
    path_parts = path.split(os.sep)
    
    # Check if any part of the path matches a pattern
    for pattern in gitignore_patterns:
        # Direct match with any path component
        if any(fnmatch.fnmatch(part, pattern) for part in path_parts):
            return True
        # Full path match
        if fnmatch.fnmatch(path, pattern):
            return True
        # Pattern starting with / (root-relative)
        if pattern.startswith('/') and fnmatch.fnmatch(path, pattern[1:]):
            return True
        # Directory pattern ending with /
        if pattern.endswith('/') and any(fnmatch.fnmatch(f"{part}/", pattern) for part in path_parts):
            return True
            
    return False


def format_file_size(size: int) -> str:
    """Format file size in human-readable format."""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size < 1024.0:
            return f"{size:.1f} {unit}"
        size /= 1024.0
    return f"{size:.1f} TB"


def generate_source_tree(root_dir: str, selected_files: Dict[str, bool], selected_only: bool = False) -> str:
    """
    Generate a source tree representation of the project.
    
    Args:
        root_dir: Root directory of the project
        selected_files: Dictionary of file paths and their selection status
        selected_only: If True, show only selected files and their directories
        
    Returns:
        String representation of the source tree
    """
    tree = []
    
    def is_hidden(path: str) -> bool:
        """Check if a path is hidden (starts with '.')"""
        return any(part.startswith('.') for part in path.split(os.sep))
    
    def get_all_files() -> List[str]:
        """Get all non-hidden files in the directory"""
        all_files = []
        for root, _, files in os.walk(root_dir):
            rel_root = os.path.relpath(root, root_dir)
            if rel_root == '.':
                rel_root = ''
            
            # Skip hidden directories
            if is_hidden(rel_root):
                continue
                
            for file in files:
                if not is_hidden(file):
                    file_path = os.path.join(rel_root, file)
                    if file_path in selected_files:  # Only include files that were considered
                        all_files.append(file_path)
        return sorted(all_files)

    def get_selected_files() -> List[str]:
        """Get only selected files"""
        return sorted([f for f, included in selected_files.items() if included])
    
    # Decide which files to show based on mode
    files_to_show = get_selected_files() if selected_only else get_all_files()
    if not files_to_show:
        return ""

    # Track all directories needed
    directories = set()
    for file_path in files_to_show:
        parts = file_path.split(os.sep)
        for i in range(len(parts)):
            dir_path = os.sep.join(parts[:i])
            if dir_path:  # Skip empty path
                directories.add(dir_path)

    # Combine directories and files
    all_paths = sorted(list(directories) + files_to_show)
    
    # Build the tree with proper indentation
    last_level = []
    for path in all_paths:
        current_level = path.split(os.sep)
        
        # Determine common prefix length
        common_len = 0
        for last, curr in zip(last_level, current_level):
            if last != curr:
                break
            common_len += 1
        
        # Add new items with proper indentation
        for i, item in enumerate(current_level[common_len:], common_len):
            prefix = "    " * i
            # Use different symbols based on type and status
            if path in files_to_show:  # It's a file
                if path in selected_files and selected_files[path]:
                    marker = "â””â”€â”€ "  # Selected file
                else:
                    marker = "â”œâ”€â”€ "  # Unselected file
            else:  # It's a directory
                marker = "â”œâ”€â”€ "
            tree.append(f"{prefix}{marker}{item}")
        
        last_level = current_level
    
    return "\n".join(tree)


def wrap_code_block(content: str, file_path: str) -> str:
    """Wrap file content in a markdown code block with appropriate language highlighting."""
    extension = os.path.splitext(file_path)[1].lstrip('.')
    if not extension:
        extension = ''
        
    if content.startswith('\ufeff'):
        content = content[1:]
    
    return f"```{extension}\n{content}\n```"
```

`project_dumper/token_utils.py`:
```py
import os
from typing import Dict, List
from .ui_utils import colored, print_header, print_status, Colors


def estimate_tokens(text: str, model: str = 'claude') -> int:
    """Estimate token count for different LLM models."""
    # Rough estimates based on average characters per token
    char_per_token = {
        'claude': 3.5,      # Claude models
        'gpt-4': 4.0,       # GPT-4
        'gpt-3.5': 4.0,     # GPT-3.5
        'gemini': 4.0,      # Google Gemini
        'llama': 3.8,       # Llama models
    }
    
    chars = len(text)
    cpt = char_per_token.get(model.lower(), 4.0)
    return int(chars / cpt)


def analyze_token_usage(root_dir: str, selected_files: Dict[str, bool]) -> Dict[str, Dict[str, int]]:
    """Analyze token usage per file for different models."""
    token_analysis = {}
    models = ['claude', 'gpt-4', 'gemini']
    
    for file, selected in selected_files.items():
        if not selected:
            continue
            
        try:
            full_path = os.path.join(root_dir, file)
            with open(full_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            token_analysis[file] = {
                'size': len(content),
                'tokens': {model: estimate_tokens(content, model) for model in models}
            }
        except:
            pass
            
    return token_analysis


def check_token_limits(output_file: str, limits: Dict[str, int]) -> None:
    """Check if output exceeds token limits and warn."""
    try:
        with open(output_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        for model, limit in limits.items():
            tokens = estimate_tokens(content, model)
            if tokens > limit:
                print_status(
                    f"Output exceeds {model} token limit ({tokens:,} > {limit:,})", 
                    "warning"
                )
    except:
        pass


def show_token_analysis(root_dir: str, selected_files: Dict[str, bool]) -> None:
    """Show detailed token analysis for selected files."""
    print_header("TOKEN ANALYSIS")
    print_status("Analyzing token usage...", "info")
    
    token_data = analyze_token_usage(root_dir, selected_files)
    
    if not token_data:
        print("No files to analyze.")
        return
    
    # Sort by Claude tokens descending
    sorted_files = sorted(token_data.items(), 
                         key=lambda x: x[1]['tokens']['claude'], 
                         reverse=True)
    
    print(f"\n{colored('Top 10 files by token count (Claude):', Colors.CYAN, bold=True)}")
    headers = f"{colored('File', Colors.CYAN):<50} {colored('Claude', Colors.BLUE):>10} {colored('GPT-4', Colors.GREEN):>10} {colored('Gemini', Colors.YELLOW):>10}"
    print(headers)
    print(colored("-" * 82, Colors.DIM))
    
    for file, data in sorted_files[:10]:
        file_display = file if len(file) <= 47 else '...' + file[-44:]
        print(f"{file_display:<50} "
              f"{data['tokens']['claude']:>10,} "
              f"{data['tokens']['gpt-4']:>10,} "
              f"{data['tokens']['gemini']:>10,}")
    
    # Total tokens
    total_tokens = {model: 0 for model in ['claude', 'gpt-4', 'gemini']}
    for data in token_data.values():
        for model in total_tokens:
            total_tokens[model] += data['tokens'][model]
    
    print(f"\n{colored('Total token counts:', Colors.CYAN, bold=True)}")
    for model, tokens in total_tokens.items():
        # Estimate cost (rough estimates)
        cost_per_1k = {'claude': 0.008, 'gpt-4': 0.03, 'gemini': 0.001}
        cost = (tokens / 1000) * cost_per_1k.get(model, 0)
        
        # Color based on model
        model_colors = {'claude': Colors.BLUE, 'gpt-4': Colors.GREEN, 'gemini': Colors.YELLOW}
        model_color = model_colors.get(model, Colors.DIM)
        
        print(f"  {colored(model.capitalize(), model_color, bold=True):>8}: {tokens:>12,} tokens (~${cost:.2f} est. input cost)")
    
    # Show token limit warnings
    print(f"\n{colored('Context window usage:', Colors.CYAN, bold=True)}")
    limits = {'claude': 200000, 'gpt-4': 128000, 'gemini': 1000000}
    for model, limit in limits.items():
        usage_pct = (total_tokens[model] / limit) * 100
        
        # Color based on usage
        if usage_pct < 80:
            status = colored("âœ“ OK", Colors.GREEN, bold=True)
            pct_color = Colors.GREEN
        elif usage_pct < 100:
            status = colored("âš ï¸  WARNING", Colors.YELLOW, bold=True)
            pct_color = Colors.YELLOW
        else:
            status = colored("âŒ EXCEEDS", Colors.RED, bold=True)
            pct_color = Colors.RED
            
        model_colors = {'claude': Colors.BLUE, 'gpt-4': Colors.GREEN, 'gemini': Colors.YELLOW}
        model_color = model_colors.get(model, Colors.DIM)
        
        print(f"  {colored(model.capitalize(), model_color):>8}: {colored(f'{usage_pct:>6.1f}%', pct_color)} of {limit//1000}k limit {status}")
```
